<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>iOS Safari 動作確認（首角度）</title>
  <style>
    body{font-family:system-ui;margin:0;background:#fafafa;color:#111}
    header{position:sticky;top:0;background:#fff;border-bottom:1px solid #eee;padding:12px}
    main{padding:12px;display:grid;gap:12px}
    .card{background:#fff;border:1px solid #eee;border-radius:14px;padding:12px}
    button{padding:10px 12px;border-radius:10px;border:1px solid #ddd;background:#111;color:#fff;font-weight:700}
    #wrap{position:relative;aspect-ratio:3/4;border-radius:14px;overflow:hidden;background:#000}
    video,canvas{position:absolute;inset:0;width:100%;height:100%;object-fit:cover}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .mono{font-family:ui-monospace,Menlo,Consolas,monospace}
  </style>

  <!-- ✅ 非module で読み込む（iOSで安定しやすい） -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
<header>
  <div class="row">
    <button id="btnStart">開始</button>
    <button id="btnCalib">3秒キャリブ</button>
    <span id="status" class="mono">未開始</span>
  </div>
</header>

<main>
  <section class="card">
    <div id="wrap">
      <video id="video" playsinline muted></video>
      <canvas id="canvas"></canvas>
    </div>
  </section>

  <section class="card">
    <div class="row">
      <div>顔Pitch: <b id="facePitch" class="mono">--</b></div>
      <div>スマホPitch(beta): <b id="phonePitch" class="mono">--</b></div>
      <div>首角度: <b id="neckAngle" class="mono">--</b></div>
    </div>
    <div style="margin-top:8px">判定: <b id="judge">--</b></div>
  </section>
</main>

<script>
  const TH_NOTICE = 10, TH_WARN = 20;

  const video = document.getElementById("video");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const elStatus = document.getElementById("status");
  const elFace = document.getElementById("facePitch");
  const elPhone = document.getElementById("phonePitch");
  const elNeck = document.getElementById("neckAngle");
  const elJudge = document.getElementById("judge");

  const btnStart = document.getElementById("btnStart");
  const btnCalib = document.getElementById("btnCalib");

  let phonePitchDeg = 0;
  let facePitchDeg = 0;
  let neckAngleDeg = 0;

  let baseFace = null;
  let basePhone = null;

  let isCal = false, calStart=0, sumF=0, sumP=0, n=0;
  const CAL_MS = 3000;

  function classify(a){
    a = Math.abs(a);
    if (a >= TH_WARN) return "曲がっている（警告）";
    if (a >= TH_NOTICE) return "やや曲がり（注意）";
    return "まっすぐ";
  }

  function ensureOrientation(){
    return new Promise(async (resolve) => {
      try{
        if (typeof DeviceOrientationEvent !== "undefined" &&
            typeof DeviceOrientationEvent.requestPermission === "function") {
          const r = await DeviceOrientationEvent.requestPermission();
          if (r !== "granted") return resolve(false);
        }
        window.addEventListener("deviceorientation", (ev) => {
          if (typeof ev.beta === "number") phonePitchDeg = ev.beta; // 逆なら -ev.beta
        }, true);
        resolve(true);
      }catch(e){
        resolve(false);
      }
    });
  }

  function facePitchFromLandmarks(lm){
    // 鼻(1)と顎(152)を使用（FaceMesh）
    const nose = lm[1], chin = lm[152];
    if (!nose || !chin) return 0;
    const dz = (chin.z - nose.z);
    const dy = (chin.y - nose.y);
    return Math.atan2(dz, Math.abs(dy) + 1e-6) * 180 / Math.PI;
  }

  function updateCal(){
    if (!isCal) return;
    const t = performance.now();
    sumF += facePitchDeg; sumP += phonePitchDeg; n++;
    if (t - calStart >= CAL_MS){
      baseFace = sumF / Math.max(1,n);
      basePhone = sumP / Math.max(1,n);
      isCal = false;
      elStatus.textContent = `キャリブ完了 baseFace=${baseFace.toFixed(1)} basePhone=${basePhone.toFixed(1)}`;
    }
  }

  function computeNeck(){
    const df = (baseFace==null) ? facePitchDeg : (facePitchDeg - baseFace);
    const dp = (basePhone==null) ? phonePitchDeg : (phonePitchDeg - basePhone);
    neckAngleDeg = df - dp;
  }

  // MediaPipe FaceMesh
  const faceMesh = new FaceMesh.FaceMesh({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`
  });
  faceMesh.setOptions({
    selfieMode: true,
    maxNumFaces: 1,
    refineLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });

  faceMesh.onResults((res) => {
    // canvasサイズ合わせ
    if (canvas.width !== video.videoWidth) {
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    }
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(res.image, 0,0,canvas.width,canvas.height);

    if (res.multiFaceLandmarks && res.multiFaceLandmarks.length > 0){
      const lm = res.multiFaceLandmarks[0];
      facePitchDeg = facePitchFromLandmarks(lm);

      drawConnectors(ctx, lm, FACEMESH_TESSELATION, {lineWidth:1});
    } else {
      facePitchDeg = 0;
    }

    updateCal();
    computeNeck();

    elFace.textContent = facePitchDeg.toFixed(1);
    elPhone.textContent = phonePitchDeg.toFixed(1);
    elNeck.textContent = neckAngleDeg.toFixed(1);
    elJudge.textContent = classify(neckAngleDeg);
  });

  let camera = null;

  btnStart.addEventListener("click", async () => {
    elStatus.textContent = "開始処理中...";
    const ok = await ensureOrientation();
    if (!ok){
      alert("モーション/傾きセンサの許可が必要です。");
      elStatus.textContent = "センサ許可NG";
      return;
    }

    try{
      const stream = await navigator.mediaDevices.getUserMedia({
        video:{facingMode:"user", width:{ideal:720}, height:{ideal:1280}},
        audio:false
      });
      video.srcObject = stream;
      await video.play();

      camera = new Camera(video, {
        onFrame: async () => { await faceMesh.send({image: video}); },
        width: 720, height: 1280
      });
      camera.start();
      elStatus.textContent = "実行中";
    }catch(e){
      console.error(e);
      alert("カメラ開始失敗: " + e);
      elStatus.textContent = "カメラ開始失敗";
    }
  });

  btnCalib.addEventListener("click", async () => {
    const ok = await ensureOrientation();
    if (!ok){
      alert("モーション/傾きセンサの許可が必要です。");
      return;
    }
    isCal = true; calStart = performance.now();
    sumF=0; sumP=0; n=0;
    elStatus.textContent = "キャリブ中…(3秒)";
  });
</script>
</body>
</html>
